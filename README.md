АРХИТЕКТУРА СЕРВИСА
===================
Итоговый сервис будет состоять из большого количества рабочих процессов, отвечающих за предварительную обработку URL,
проверки, формирование ответа и общего распределённого хранилища.

На входе URL, переданный для сокращения проверяется на допустимость (максимальная длина, валидность самого URL, допустимые
схемы, возможно проверки безопасности, спама и т.п.).

Когда все проверки пройдены из адреса создается ключ, с которым url сохраняется в базу данных.

Затем клиенту возвращается адрес сервиса + закодированный id сохранённого адреса.

Создание, кодирование идентификатора и сохранение соответствия короткого и исходного URL выделено в отдельные модули для 
удобства проведения экспериментов и разных подходов на прототипе.

ВЫБОР ЯЗЫКА
===========

Я хорошо знаком с Go и этот язык хорошо подходит для решения текущей задачи:
хорошая работа с легковесными потоками, малое потребление ресурсов, большое количество библиотек для
тестирвоания разных подходов
поэтому он выбран для написания прототипа.

Вторым претендентом был Erlang, однако с ним у меня опыта намного меньше + для Erlang намного меньше
готовых библиотек - дольше экспериментировать с разными подходами.

ВЫБОР ВСПОМОГАТЕЛЬНЫХ ИНСТРУМЕНТОВ:
===================================

Хранилище
---------
На данный момент хранилищем выбран Redis.

Для быстрого сервиса нужен быстрый способ сохранять данные, врядли получится сохранить данные быстрее,
чем в оперативную память.

В качестве начального хранилища выбран Redis, т.к. в сравнении с Tarantool он показал выше скорость операций + проще
интерфейс + это давно известный и широкоиспользуемый продукт. В Tarantool больше возможностей в части написания
хранимок, на практике или под большими нагрузками продукты могут повести себя по-другому (публикации Mail.RU говорят
о падении скорости Redis под большими нагрузками на один экземпляр). Поэтому в коде оставлены обе реализации с 
простой возможностью переключения ними и сравнения на рабочих сценариях

### Примечания
В коде дополнительно реализованы локальные хранилища на файлах и в памяти процесса - это удобно для разработки.

Создание идентификаторов
------------------------
Выбрано создание случайных идентификаторов.

Рассматривались два варианта:
1. Хеш от входящего URL
2. Случайный идентификатор

### Преимущества хеша
На разных экземплярах при одном входящем URL будет создан один и тот же короткий URL. Это может быть удобно для
балансировки, отказоустойчивости с обеспечением на стороне клиента/балансировщика. Сложно угадать перебором.

Самый быстрый вариант хешей на данный момент - SipHash64.

### Преимущества случайного идентификатора
На средних/длинных URL работает быстрее хешей. Простота разрешения коллизий - просто сгенерировать ещё раз.

### Примечания
В коде пока оставлен немного усложнённый вариант - для генерирования идентификаторов из хешей, для общности и простоты переключений
если потребуются эксперименты.

HTTP-сервер
-----------
Вместо встроенного http-сервера Go используется сервер fasthttp, т.к. он работает заметно быстрее с меньшей нагрузкой
на копирования в памяти и сборщик мусора.

