АРХИТЕКТУРА СЕРВИСА
===================
Итоговый сервис будет состоять из большого количества рабочих процессов, отвечающих за предварительную обработку URL,
проверки, формирование ответа и общего распределённого хранилища.

На входе URL, переданный для сокращения проверяется на допустимость (максимальная длина, валидность самого URL, допустимые
схемы, возможно проверки безопасности, спама и т.п.).

Когда все проверки пройдены из адреса создается ключ, с которым url сохраняется в базу данных.

Затем клиенту возвращается адрес сервиса + закодированный id сохранённого адреса.

Создание, кодирование идентификатора и сохранение соответствия короткого и исходного URL выделено в отдельные модули для 
удобства проведения экспериментов и разных подходов на прототипе.

ВЫБОР ЯЗЫКА
===========

Я хорошо знаком с Go и этот язык хорошо подходит для решения текущей задачи:
хорошая работа с легковесными потоками, малое потребление ресурсов, большое количество библиотек для
тестирвоания разных подходов
поэтому он выбран для написания прототипа.

Вторым претендентом был Erlang, однако с ним у меня опыта намного меньше + для Erlang намного меньше
готовых библиотек - дольше экспериментировать с разными подходами, это существенно для прототипа.

ВЫБОР ВСПОМОГАТЕЛЬНЫХ ИНСТРУМЕНТОВ:
===================================

Хранилище
---------
В качестве основного хранилища для рабочего режима я бы начал с Tarantool. Хоть в локальных тестах он показал чуть меньшую
производительность - у него есть удобные возможности для дальнейшего роста функционала: хранимые процедуры для скорости
и атомарности выполнения связанных операций, возможность хранения данных на диске, 
встроенная возможность подключения к внешним базам данных.

Для упрощения первичной настройки, тестовых окружения или на локальных машинах разработчиков можно использовать хранилища
memory-map или files - т.к. они не требуют настройки внешних сервисов.

Для сравнения так же был реализован бэкенд на Redis. На данный момент взаимодействие с бэкендом простое и запасная 
реализация позволит сравнить поведение хранилищ под высокими нагрузками

Создание идентификаторов
------------------------
Выбрано создание случайных идентификаторов.

Рассматривались два варианта:
1. Хеш от входящего URL
2. Случайный идентификатор

### Преимущества хеша
На разных экземплярах при одном входящем URL будет создан один и тот же короткий URL. Это может быть удобно для
балансировки, отказоустойчивости с обеспечением на стороне клиента/балансировщика. Сложно угадать перебором.

Самый быстрый вариант хешей на данный момент - SipHash64. Отдельно стоит вопрос количества коллизий при сохранениях
что одинаковых, что разных URL. Для одинаковых URL, но разных клиентов до хеширования к строке можно подмешивать какие-то
данные вроде UserAgent, IP-адреса, текущего времени, счётчика, куки-идентификатора клиента и т.п. - для минимизации 
коллизий при одинаковых URL. В целом думаю этот вопрос следует исследовать отдельно.

### Преимущества случайного идентификатора
На средних/длинных URL случайные функции работают быстрее хешей. Простота разрешения коллизий - просто сгенерировать ещё раз.

Отрицательной стороной служит теоретическая угадываемость, если в качестве генератора случайных чисел брать встроенную 
реализацию, а не crypto-случайные числа. Крипто-случайные числа генерируются медленно. Возможно этот вопрос следует
исследовать отдельно, в зависимости от стоящих задач.
В качестве увеличения энтропии счетчик случайных чисел инициализируются крипто-случайным числом. Так же можно время от 
времени проводить его переинициализацию.

### Примечания
В коде пока оставлен немного усложнённый вариант - для генерирования идентификаторов из хешей, для общности и простоты переключений
если потребуются эксперименты.

HTTP-сервер
-----------
Вместо встроенного http-сервера Go используется сервер fasthttp, т.к. он работает заметно быстрее с меньшей нагрузкой
на копирования в памяти и сборщик мусора, чем реализация из стандартной библиотеки.

Tarantool-драйвер
-----------------
Выбрана реализация из официального репозитория Tarantool

Redis-драйвер
-------------
Выбрана реализация с наиболее простым и понятным интерфейсом из списка рекомендуемых на сайте Redis.

Benchmark results
=========

    BenchmarkHashMD5_48Bit-4                 3000000               511 ns/op
    BenchmarkHashSha256-4                    1000000              1663 ns/op
    BenchmarkHashSipDchest_48bit-4           3000000               416 ns/op
    BenchmarkHashSipDchestFast_48bit-4      10000000               206 ns/op
    BenchmarkHashSipAeadSip_48bit-4          3000000               401 ns/op
    BenchmarkHashRandom_48bit-4             20000000                91.0 ns/op
    BenchmarkHashRandomCrypto_48Bit-4        2000000               913 ns/op
    BenchmarkStorageFiles_Store-4             500000              3798 ns/op
    BenchmarkStorageMap_Store-4              3000000               776 ns/op
    BenchmarkStorageRedis_Store-4             100000             16296 ns/op
    BenchmarkStorageTarantool_Store-4         100000             18326 ns/op
